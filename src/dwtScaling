#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Sep 24 21:10:59 2019

@author: johan
"""

import dwtFirstPrinciples as dwt
import numpy as np

'''
def dwtScaleEncoding(coverSamples, message, messageType):
      samplesUsed = 0
      
      # Embed the messagelength within the message
      messageLength = len(message)
      
      # Get the count. Number of 1's in the binary represenetation of the length 
      # of the message
      doBreak = False  
      blockNumber = 0     
      
      # Convert the message to the ASCII representation as a integer list
      message = list(map(ord,message))
      
      # Subtract the count from every ASCII character of the message
      for i in range(0, messageLength):
          message[i] = message[i] - count
      
      # Divide by 10000 to get four decimal digits
      message = list(np.asarray(message)/1000)

      # Get the approximate coefficients and detail coefficients of the signal
      coefficiets = dwt.getCoefficients(coverSamples, blockLength)
      
      # Get the type of message
      # 0 is a textmessage and 1 is a wave message
      typeMessage = 0
    
      if (messageType == ".txt"):
          typeMessage = 0
        
      elif (messageType == ".wav"):
          typeMessage = 1
                
      # Insert the type of message as the second element and the message length 
      # as the first element
      message.insert(0, typeMessage)
      message.insert(0, messageLength/1000)
      
      for blockNumber in range(0, len(coefficiets[1])):
          for i in range(0, len(coefficiets[1][blockNumber])):
              # Replace the coefficient by the encrypted ascii char
              
#              if (coefficiets[1][blockNumber][i] > 0):
#                  coefficiets[1][blockNumber][i] = int(coefficiets[1][blockNumber][i]) + message[0]
#                  
#              else:    
#                  coefficiets[1][blockNumber][i] = int(coefficiets[1][blockNumber][i]) - message[0]
              
              coefficiets[1][blockNumber][i] = message[0]
              message = message[1:]
              samplesUsed = blockNumber * blockLength + (i + 1)*2
              

              # If the message is embedded, break
              if (len(message) == 0):
                  doBreak = True
                  break
              
          if (doBreak == True):
              break
              
          
      if (len(message) > 0):
          print("Message bits unembedded:", len(message))
              
      # Reconstruct the signal
      stegoSamples = []
      for i in range(0, len(coefficiets[1])):
          temp = dwt.getSignal(coefficiets[0][i], coefficiets[1][i])
          temp = list(map(float, temp))
          stegoSamples += temp
      
      unaltered = coverSamples[-1*(len(coverSamples) - len(stegoSamples)):]
      print(coefficiets[1][0][0:10])
      return stegoSamples + unaltered, samplesUsed
'''


print(np.binary_repr(2**32, 100000000))